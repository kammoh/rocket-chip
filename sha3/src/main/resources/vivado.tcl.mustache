set REPORTS_DIR {{output_dir}}/reports
set CHECKPOINTS_DIR {{output_dir}}/checkpoints

set parts [get_parts]

puts "available devices: $parts"

if {[lsearch -exact $parts {{part}}] < 0} {
    puts "ERROR: device {{part}} is not supported"
    quit
}

puts "using {{part}}"


# if { $argc != 2 } {
#         puts "The script requires two numbers to be input."
# } else {
#         puts "[lindex $argv 0] [lindex $argv 1]"
# }

file mkdir {{output_dir}}
file mkdir $REPORTS_DIR
file mkdir [file join $REPORTS_DIR post_synth]
file mkdir [file join $REPORTS_DIR post_place]
file mkdir [file join $REPORTS_DIR post_route]
file mkdir $CHECKPOINTS_DIR


proc reportCriticalPaths { fileName } {
# Open the specified output file in write mode
set FH [open $fileName w]
# Write the current date and CSV format to a file header
puts $FH "#\n# File created on [clock format [clock seconds]]\n#\n"
puts $FH "Startpoint,Endpoint,DelayType,Slack,#Levels,#LUTs"
# Iterate through both Min and Max delay types
foreach delayType {max min} {
# Collect details from the 50 worst timing paths for the current analysis
# (max = setup/recovery, min = hold/removal)
# The $path variable contains a Timing Path object.
foreach path [get_timing_paths -delay_type $delayType -max_paths 50 -nworst 1] {
# Get the LUT cells of the timing paths
set luts [get_cells -filter {REF_NAME =~ LUT*} -of_object $path]
# Get the startpoint of the Timing Path object
set startpoint [get_property STARTPOINT_PIN $path]
# Get the endpoint of the Timing Path object
set endpoint [get_property ENDPOINT_PIN $path]
# Get the slack on the Timing Path object
set slack [get_property SLACK $path]
# Get the number of logic levels between startpoint and endpoint
set levels [get_property LOGIC_LEVELS $path]
# Save the collected path details to the CSV file
puts $FH "$startpoint,$endpoint,$delayType,$slack,$levels,[llength $luts]"
}
}
# Close the output file
close $FH
puts "CSV file $fileName has been created.\n"
return 0
}; # End PROC


{{#verilog_sources}}
    read_verilog {{path}}
{{/verilog_sources}}

{{#xdcs}}
    read_xdc {{path}}
{{/xdcs}}


#synth_design -top {{top_module_name}} -rtl -rtl_skip_ip -keep_equivalent_registers -control_set_opt_threshold 0 -assert -no_timing_driven -resource_sharing off -flatten_hierarchy none

#write_verilog -force {{output_dir}}/{{top_module_name}}_synth_rtl.v
synth_design {{synth_options}}
# synth_design -top {{top_module_name}} -keep_equivalent_registers -control_set_opt_threshold 0 -assert -no_timing_driven -resource_sharing off -flatten_hierarchy none

# report_utilization -file $REPORTS_DIR/pre_opt_utilization.rpt


# directive: Default, RuntimeOptimized, ExploreArea, Explore, etc
# OR # -merge_equivalent_drivers -control_set_merge -resynth_area -remap  -propconst
opt_design {{opt_options}}

# write_checkpoint -force {{output_dir}}/post_synth

report_timing_summary -file $REPORTS_DIR/post_synth/timing_summary.rpt
report_utilization -file $REPORTS_DIR/post_synth/utilization.rpt
reportCriticalPaths $REPORTS_DIR/post_synth/critpath_report.csv
report_methodology  -file $REPORTS_DIR/post_synth/methodology.rpt
# report_power -file $REPORTS_DIR/post_synth/power.rpt

place_design -directive Explore

phys_opt_design {{phys_opt_options}}

power_opt_design

#write_checkpoint -force $CHECKPOINTS_DIR/post_place
report_timing_summary -file [file join $REPORTS_DIR post_place timing_summary.rpt] -max_paths 10

route_design -directive Explore
phys_opt_design -directive Explore


#write_checkpoint -force $CHECKPOINTS_DIR/post_route
report_timing_summary -file [file join $REPORTS_DIR post_route timing_summary.rpt] -max_paths 10
report_timing  -sort_by group -max_paths 100 -path_type summary -file $REPORTS_DIR/post_route/timing.rpt
reportCriticalPaths $REPORTS_DIR/post_route/critpath_report.csv
report_clock_utilization -file $REPORTS_DIR/clock_utilization.rpt
report_utilization -file $REPORTS_DIR/post_route/utilization.rpt
report_utilization -hierarchical  -file   $REPORTS_DIR/post_route/hierarchical_utilization.rpt.rpt
report_power  -file  $REPORTS_DIR/post_route/power.rpt
report_drc  -file  $REPORTS_DIR/post_route/drc.rpt

report_ram_utilization -file $REPORTS_DIR/post_route/ram_utilization.rpt -append -detail

# report_power -file $REPORTS_DIR/post_route/power.rpt
# report_drc -file $REPORTS_DIR/post_route/drc.rpt
# report_methodology  -file $REPORTS_DIR/post_route/methodology.rpt


{{#write_verilog}}
    puts "writing implemented netlist Verilog and SDF"
    write_sdf -force {{output_dir}}/{{top_module_name}}_impl_netlist.v.sdf
    write_verilog -include_xilinx_libs -sdf_anno -force {{output_dir}}/{{top_module_name}}_impl_netlist.v
{{/write_verilog}}

# write_vhdl -force {{output_dir}}/{{top_module_name}}_impl_netlist.vhdl
# write_xdc -no_fixed_only -force {{output_dir}}/{{top_module_name}}_impl.xdc

# write_bitstream -force {{output_dir}}/{{top_module_name}}.bit


puts "\n\n** Vivado run completed **\n"
puts "** Number of Errors: [get_msg_config -severity {ERROR} -count]"
puts "** Number of Critical Warnings: [get_msg_config -severity {CRITICAL WARNING} -count]"
puts "** Number of Warnings: [get_msg_config -severity {WARNING} -count]\n\n"

set timing_slack [get_property SLACK [get_timing_paths]]
if {$timing_slack < 0} {
puts "ERROR: Failed to meet timing by $timing_slack, see [file join $REPORTS_DIR post_route timing_summary.rpt]"
exit 1
}

quit
